{"meta":{"title":"蜗小牛","subtitle":"Continue coding","description":"","author":"蜗小牛","url":"http://example.com","root":"/"},"pages":[{"title":"文章分类","date":"2020-11-01T16:00:00.000Z","updated":"2022-09-05T06:20:26.606Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2022-09-05T06:10:39.920Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"个人简介","date":"2022-09-05T16:00:00.000Z","updated":"2022-09-06T08:53:01.643Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"关于我 后端开发工程师GitHub：蜗小牛的Github 联系方式 微信 邮件：&#x31;&#51;&#54;&#49;&#52;&#x35;&#48;&#52;&#x30;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109; 朋友们 beOkWithAnything 无情码手"},{"title":"tags","date":"2020-09-19T08:19:22.000Z","updated":"2022-09-05T06:18:49.109Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-09-06T02:36:22.000Z","updated":"2022-09-06T02:36:22.482Z","comments":true,"path":"categories/index-1.html","permalink":"http://example.com/categories/index-1.html","excerpt":"","text":""}],"posts":[{"title":"序","slug":"序","date":"2022-09-06T07:20:31.000Z","updated":"2022-09-06T08:24:37.862Z","comments":true,"path":"2022/09/06/序/","link":"","permalink":"http://example.com/2022/09/06/%E5%BA%8F/","excerpt":"","text":"这里是蜗小牛的个人博客","categories":[],"tags":[]},{"title":"单点登陆(Single Sign On)","slug":"SSO登陆","date":"2022-09-05T06:50:43.000Z","updated":"2022-09-05T06:51:36.841Z","comments":true,"path":"2022/09/05/SSO登陆/","link":"","permalink":"http://example.com/2022/09/05/SSO%E7%99%BB%E9%99%86/","excerpt":"","text":"单点登陆(Single Sign On)单点登陆 : 在一个企业中, 系统由多个子系统构成, 访问每个子系统都需要单独登陆, 造成重复登陆多次, 操作复杂, 单点登陆即只需要登陆一次, 即可访问所有子系统. 在主流的登陆方案中, 都是使用 cookie/session 的解决方案, 即 浏览器端存储 cookie 信息, 服务端存储 session 信息, 浏览器的每次操作, 都会携带 cookie 到服务端, 服务端校验该 cookie 是否已存在对应的 session 信息, 如果存在, 就允许浏览器进行操作, 不存在, 说明用户未登陆, 提示用户登陆. 登陆后, 创建cookie&#x2F;session关联关系, 后续即可访问即可正常进行. 在多系统集成的场景下, 不同的系统部署在不同的domain域中(即 ip&#x2F;port 不同), 由于浏览器的 **同源策略** 和 **cookie作用域** 的限制, 登陆系统A后, 会生成系统A的cookie, 这个cookie 的domain域限定为A (即只有在操作系统A时, 浏览器才会发送该cookie); 而如果操作系统B, 并不会发送系统A的cookie, 此时就需要再次登陆系统B, 才能生成系统B的 cookie&#x2F;session 关系. 12345浏览器同源策略限制内容包括:1. Cookie, LocalStorage 和 IndexDB 无法跨域读取.2. DOM 无法跨域获取.3. Ajax 请求无法跨域发送 1234Cookie作用域：1. domain: 表示cookie所在的域，默认为请求的地址. 如网址为 www.google.com/test/test.html，那么domain默认为www.google.com. 如果要跨域访问，例如 域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。2. path: 表示cookie所在的目录, 默认为/, 即根目录. 例如 在同一个服务器上有目录如下：/test/, /test/cd/, /test/dd/，假设一个cookie1 的path为/test/，cookie2的path为/test/cd/，那么test下的所有页面都可以访问到cookie1，而/test/ 和 /test/dd/的子页面不能访问cookie2. 因为cookie仅能让其path路径下的页面访问. 整体流程说明 NOTE 单点登陆流程基于OAuth2协议的 授权码模式(authorization code) 第一次登陆 浏览器请求 http://customer.com 域的 Nginx . Nginx 将请求转发到 Gateway. (此处Nginx反向代理解决了Ajax跨域问题). Gateway 判断如果用户未登陆, 则返回 认证服务器 的URL. 前端对返回的 认证服务器 的URL进一步处理, 添加自定义的 重定向URL 地址. 前端使用上一步处理后的 认证服务器 URL跳转到 认证服务器. 在 认证服务器 , 如果用户未登陆, 返回登陆页面. 用户输入用户名&#x2F;密码, 提交登陆. 登陆成功后, 认证服务器 会回跳到前端自定义的 重定向URL 地址, 并且会在 URL中携带 code 与 state 参数(state 是可选的). 前端收到 认证服务器 的重定向请求, 可以得到 code 值, 使用该值作为参数再次对网关发起认证请求. (需要将 redirect_uri 与 registration_id 也加入请求参数) Nginx 将该请求转发至网关. 网关收到请求后, 会在后台调用 认证服务器 验证该 code 是否有效. 验证成功, 会返回用户的登陆信息, 网关使用这些登陆信息创建 session. 网关为前端返回用户登陆信息. 前端渲染展现用户登陆信息. 第二次登陆 浏览器请求 http://order.com 域的 Nginx . Nginx 将请求转发到 Gateway. Gateway 判断如果用户未登陆, 则返回 认证服务器 的URL. 前端对返回的 认证服务器 的URL进一步处理, 添加自定义的 重定向URL 地址. 前端使用上一步处理后的 认证服务器 URL跳转到 认证服务器. 在 认证服务器 , 如果用户已登陆, 会回跳到前端自定义的 重定向URL 地址, 并且会在 URL中携带 code 与 state 参数(state 是可选的). 前端收到 认证服务器 的重定向请求, 可以得到 code 值, 使用该值作为参数再次对网关发起认证请求. (需要将 redirect_uri 与 registration_id 也加入请求参数) Nginx 将该请求转发至网关. 网关收到请求后, 会在后台调用 认证服务器 验证该 code 是否有效. 验证成功, 会返回用户的登陆信息, 网关使用这些登陆信息创建 session. 网关为前端返回用户登陆信息. 前端继续处理业务操作. 请求响应示例未登陆时, 网关返回响应 12345678910111213141516171819Status Code: 403Authentication: gateway-ssoContent-Type: application/json;charset=UTF-8&#123; &quot;msg&quot;: &quot;Full authentication is required to access this resource&quot;, &quot;sso_flows&quot;: &#123; &quot;github&quot;: &#123; &quot;registrationId&quot;: &quot;github&quot;, &quot;redirectUri&quot;: &quot;https://github.com/login/oauth/authorize?response_type=code&amp;client_id=8c2c3e2f52ade799ed5f&amp;scope=read%3Auser&amp;redirect_uri=&quot;, &quot;authenticationUri&quot;: &quot;/login/oauth2/code/github&quot; &#125;, &quot;bss-login&quot;: &#123; &quot;registrationId&quot;: &quot;bss-login&quot;, &quot;redirectUri&quot;: &quot;http://172.21.2.41:9010/oauth/authorize?response_type=code&amp;client_id=bss-login&amp;scope=user&amp;redirect_uri=&quot;, &quot;authenticationUri&quot;: &quot;/login/oauth2/code/bss-login&quot; &#125; &#125;&#125; 其中 redirectUri节点 表示 认证服务器 的地址, 需要将该URL中的 redirect_uri= 参数补全为前端自定义的重定向地址(地址要用URLEncode进行编码). authenticationUri 表示前端拿到OAuth2授权码流程中的 code 值后, 要将该值提交给网关完成认证的地址. 前端请求响应 前端拿到Gateway的未登陆响应后, 可以根据 redirectUri 值构建 如 http://172.21.2.41:9010/oauth/authorize?response_type=code&amp;client_id=bss-login&amp;scope=user&amp;redirect_uri=https://baidu.com&amp;state=123 的跳转地址, 其中 redirect_uri 表示认证服务器登陆成功后重定向的地址, 一般是本应用的某个预定地址 (例子中redirect_uri参数为 https://baidu.com 仅仅是举例使用), state可以随意自定义或为空. 在 认证服务器 登陆成功后, 会重定向回到前端自定义的 redirect_uri 地址, 并携带 code 和 state 参数. 例如上面的认证请求会重定向为: https://www.baidu.com/?code=Gij0h3&amp;state=123 (state与请求值相同) 前端从URL参数获得 code 的值, 在加上 redirect_uri (重定向地址) 与 registration_id (OAuth2授权码流程标识) 作为参数, 再次提交 Get 请求到网关. 例如: http://localhost:8080/login/oauth2/code/bss-login?redirect_uri&#x3D;https://baidu.com&registration_id&#x3D;bss-login&amp;code&#x3D;Gij0h3 ; 如果验证成功, 网关会返回 登陆的用户信息. 1234567891011121314&#123; &quot;password&quot;: null, &quot;username&quot;: &quot;sitech01&quot;, &quot;authorities&quot;: [], &quot;accountNonExpired&quot;: true, &quot;accountNonLocked&quot;: true, &quot;credentialsNonExpired&quot;: true, &quot;enabled&quot;: true, &quot;sysUserCode&quot;: null, &quot;orgId&quot;: &quot;10031&quot;, &quot;lanId&quot;: &quot;8140100&quot;, &quot;regionId&quot;: &quot;8140100&quot;, &quot;systemPostId&quot;: &quot;10000000000003&quot;&#125; 网关的认证处理 网关在拦截到 /login/oauth2/code/&#123;registrationId&#125; 的请求后, 会获取 code 值, 在网关内部 通过 POST 和 Basic Auth 的请求调用认证服务器, 例如: http://172.21.2.41:9010/oauth/token?client_id&#x3D;bss-login&amp;grant_type&#x3D;authorization_code&amp;redirect_uri&#x3D;https://baidu.com&code=i6NV3c .网关服务器校验 code 和 Basic Auth 成功后, 返回 access_token . 网关取到 access_token 后, 再使用 access_token 的值构建 http://172.21.2.41:9010/user?access_token=dc8ef253-192e-4273-8016-48ce5cf3432a 请求访问 资源服务器 (此处资源服务器与认证服务器是同一个应用), 获得用户信息. 根据返回的用户信息创建 session Vue 前端示例1.第一次登陆 在router&#x2F;index.js配置请求项目根路径，跳转到一个自定义的空白页BlankContent 123456789&#123; path: &quot;/&quot;, redirect: &quot;blank&quot;,&#125;,&#123; path: &quot;/blank&quot;, component: () =&gt; import(&quot;@/components/layout/BlankContent&quot;),&#125; 以本地项目举例 在浏览器上输入地址 http://localhost:9093/#/ ，跳转到空白页BlankContent，为了用户体验可以增加loading的效果 空白页创建的同时发送请求 http://172.21.12.114:9080/oauth2/principal 到网关 config&#x2F;index.js 1234567891011// 网关登录&quot;/oauth2&quot;: &#123; target: &quot;http://172.21.12.114:9080&quot;, // 接口的域名 //secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 pathRewrite: &#123; &quot;&quot;: &quot;&quot; &#125;&#125;, service&#x2F;url&#x2F;base-center-url.js 1remoteLogin:&#x27;/oauth2/principal&#x27;, service&#x2F;api&#x2F;base-center.js 123remoteLogin: function remoteLogin(param) &#123; return request.get(baseServiceUrl.remoteLogin, param, true);&#125;, 由于没有登录，网关返回403响应，在public&#x2F;request.js拦截403响应进行处理，携带自定义redirectUri重定向到认证服务器上，拼成 http://172.21.2.41:9010/oauth/authorize?response_type=code&amp;client_id=bss-login&amp;scope=user&amp;redirect_uri=http:%2F%2Flocalhost:9093%2F%23%2Fblank 1234567function handlerLoginInterceptor(response)&#123; let location = window.location; let redirectHost = location.protocol + encodeURIComponent(&quot;//&quot;) + location.host; let bssLogin = response.data.sso_flows[&quot;bss-login&quot;]; let redirectUri = bssLogin.redirectUri + redirectHost + encodeURIComponent(&quot;/#/blank&quot;); window.location.href = redirectUri;&#125; 再次重定向到 http://172.21.2.41:9010/login ，展示登录页 在登录页上输入用户名密码，点击登录按钮，如果校验成功，会重定向到自定义redirectUri 地址，并携带code值， http://localhost:9093/?code=l4ct5Z 空白页BlankContent从url参数中获取code值，再加上redirect_uri和registration_id作为参数，再次提交到网关 http://172.21.12.114:9080/login/oauth2/code/bss-login?redirect_uri=http:%2F%2Flocalhost:9093%2F%23%2Fblank&amp;registration_id=bss-login&amp;code=l4ct5Z config&#x2F;index.js 1234567891011// 认证登录&quot;/login&quot;: &#123; target: &quot;http://172.21.12.114:9080&quot;, // 接口的域名 //secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 pathRewrite: &#123; &quot;&quot;: &quot;&quot; &#125;&#125;, service&#x2F;url&#x2F;base-center-url.js 1oauth:&#x27;/login/oauth2/code/bss-login&#x27;, service&#x2F;api&#x2F;base-center.js 123oauth: function oauth(param) &#123; return request.get(baseServiceUrl.oauth, param);&#125;, 认证成功，前端把返回的session信息保存起来，并且跳转到index首页 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;script&gt; import &#123; baseApi &#125; from &quot;@/service/api&quot;; import &#123; Base64 &#125; from &#x27;js-base64&#x27;; export default &#123; name: &quot;BlankContent&quot;, created() &#123; this.redirectToUrl(); &#125;, data()&#123; return&#123; redirectLocation: &quot;&quot; &#125; &#125;, methods: &#123; redirectToUrl: function() &#123; this.getLocation(); let pathname = window.location.href; if(pathname.indexOf(&quot;code&quot;) !== -1) &#123; let temp = pathname.substring(pathname.indexOf(&quot;code&quot;) + 5); let code = temp.substring(0, temp.indexOf(&quot;#&quot;)); let param = &#123; redirect_uri: this.redirectLocation + &quot;#/blank&quot;, registration_id: &quot;bss-login&quot;, code: code &#125; baseApi.oauth(param).then(res =&gt; &#123; sessionStorage.setItem(&#x27;userName&#x27;, res.data.username); sessionStorage.setItem(&quot;sessionData&quot;, Base64.encode(JSON.stringify(res.data))); sessionStorage.setItem(&quot;sessionDataOriginal&quot;, JSON.stringify(res.data)); this.goToIndex(); &#125;); &#125; else &#123; baseApi.remoteLogin().then(res =&gt;&#123; // 如果登录成功，再次访问起始地址，直接跳转到首页 if(res !== undefined &amp;&amp; res.status === 200 &amp;&amp; res.data.username !== null)&#123; this.goToIndex(); &#125; &#125;); &#125; &#125;, // 跳转到首页 goToIndex: function()&#123; window.location.href = this.redirectLocation + &quot;#/main/index&quot;; &#125;, // 获取地址协议和端口号 getLocation: function()&#123; let location = window.location; this.redirectLocation = location.protocol + &quot;//&quot; + location.host + &quot;/&quot;; &#125; &#125; &#125;&lt;/script&gt; 2.第二次登录 访问 http://localhost:9093/#/ ，跳转到空白页BlankContent，发送 http://172.21.12.114:9080/oauth2/principal 请求到网关 网关发现登录成功，返回200状态，前端直接重定向到index首页 3.退出 点击退出按钮，首先向网关发送请求 config&#x2F;index.js 1234567891011// 网关退出&quot;/oauth2-logout&quot;: &#123; target: &quot;http://172.21.12.114:9080&quot;, // 接口的域名 //secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 pathRewrite: &#123; &quot;&quot;: &quot;&quot; &#125;&#125; service&#x2F;url&#x2F;base-center-url.js 1oauth2Logout:&#x27;/oauth2-logout&#x27;, service&#x2F;api&#x2F;base-center.js 123oauth2Logout: function oauth2Logout(param) &#123; return request.post(baseServiceUrl.oauth2Logout, param, true);&#125; 网关退出成功后，携带要重定向的地址，发送请求到认证服务器上 http://172.21.2.41:9010/logout?redirect_uri&#x3D;http://localhost:9093/#/ 12345678910111213141516171819202122232425262728logout () &#123; let _this = this; this.$dialog(&#123; type: &quot;info&quot;, title: &quot;提示&quot;, text: &quot;确定要退出登录吗？&quot;, confirmDialog: function () &#123; // 网关退出 baseApi.oauth2Logout().then(res=&gt;&#123; if(res !== undefined &amp;&amp; res.status == 200)&#123; // 认证退出 let location = window.location; let url = location.protocol + &quot;//&quot; + location.host + &quot;/&quot;; window.location.href = res.data.authserverUrl + &quot;?redirect_uri=&quot; + url; sessionStorage.removeItem(&quot;userName&quot;); sessionStorage.removeItem(&quot;sessionData&quot;); sessionStorage.removeItem(&quot;sessionDataOriginal&quot;); sessionStorage.removeItem(&quot;tagsView&quot;); _this.$store.dispatch(&quot;clearLocation&quot;); _this.$store.dispatch(&quot;clearstate&quot;); &#125; &#125;); &#125;, closeDialog: function () &#123; console.log(&quot;取消！&quot;) &#125; &#125;)&#125; 认证服务器退出，重定向到 http://localhost:9093/#/ ，由于没有了session，网关返回403响应，被拦截重定向到 http://172.21.2.41:9010/login 基于KONG的前后端分离流程Session 信息获取应用在网关登陆认证成功后, 所有通过网关请求 后端服务 的 Http Request, 网关会自动为其增加一组 x-session- 前缀的Http Headers, 这些 Http Headers携带了登陆的 Session信息, 后端服务可以通过这些Http Headers获取到 session信息. 后端获取Session在使用SpringMVC的后端中, 可以通过 @RequestHeader(value&#x3D;”x-session-username”) 来获取Http Headers中携带的 x-session-username 的值。 Http Header中 x-session-username 的值 即对应于 session 中的 username 值。 代码示例 123456789101112@GetMapping(&quot;/hello/&#123;latency&#125;&quot;)public String hello(@PathVariable(&quot;latency&quot;) int latency, @RequestHeader HttpHeaders httpHeaders, @RequestHeader(value=&quot;x-session-username&quot;, required=false) String sessionUserName) &#123; System.out.println(&quot;x-session-username -&gt; &quot; + sessionUserName); Map&lt;String, String&gt; headersMap = httpHeaders.toSingleValueMap(); headersMap.forEach((k, v) -&gt; &#123; System.out.println(k + &quot; : &quot; + v); &#125;); return &quot;Hello World!&quot;;&#125; 访问受保护资源(access_token)网关作为 Resource Server(资源服务器), 保护后端服务的API, 三方如果需要访问网关上的API, 需要到 Authorization Server(授权认证服务器) 上获取access_token, 通过access_token 才能访问网关上的API. OAuth2密码模式密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。 在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式. 网关的认证处理 （A）用户向客户端提供用户名和密码。 （B）客户端将用户名和密码发给认证服务器，向后者请求令牌。 （C）认证服务器确认无误后，向客户端提供访问令牌。 为客户端分配用户名和密码, 例如分配的 用户名&#x2F;密码 为 sitech01&#x2F;sitech01 客户端使用分配的 用户名&#x2F;密码 请求 Authorization Server, 以获取 access_token. 使用 access_token 获取用户认证信息. access_token存在失效时间, 在 Authorization Server 的返回参数中, expires_in 表示失效的剩余时间(秒), 可以在失效前使用 refresh_token 刷新 access_token. 密码模式获取access_token POST http://172.21.2.41:9010/oauth/token Request Headers: 12345678POST /oauth/tokenContent-Type: application/x-www-form-urlencodedcache-control: no-cacheAuthorization: Basic YnNzLWxvZ2luOmJzcy1sb2dpbi0yMDE4Accept: */*Host: 172.21.2.41:9010accept-encoding: gzip, deflatecontent-length: 55 Request Body: 1grant_type=password&amp;username=sitech01&amp;password=sitech01 Response Headers: 12345678910HTTP/1.1 200status: 200Pragma: no-cacheCache-Control: no-storeX-Content-Type-Options: nosniffX-XSS-Protection: 1; mode=blockX-Frame-Options: DENYContent-Type: application/json;charset=UTF-8Transfer-Encoding: chunkedDate: Wed, 09 Jan 2019 07:48:14 GMT Response Body: 1234567&#123; &quot;access_token&quot;: &quot;66ba0223-4335-4085-a2dd-91cb4646fdd9&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;refresh_token&quot;: &quot;5a4d7d4e-de41-4f97-9785-52e42a10c6c9&quot;, &quot;expires_in&quot;: 17389, &quot;scope&quot;: &quot;user&quot;&#125; 使用access_token获取用户信息 GET http://172.21.2.41:9010/user?access_token=66ba0223-4335-4085-a2dd-91cb4646fdd9 Response Body: 123456789101112131415161718192021&#123; &quot;password&quot;: null, &quot;username&quot;: &quot;sitech01&quot;, &quot;authorities&quot;: [], &quot;accountNonExpired&quot;: true, &quot;accountNonLocked&quot;: true, &quot;credentialsNonExpired&quot;: true, &quot;enabled&quot;: true, &quot;sysUserCode&quot;: &quot;sitech01&quot;, &quot;sysUserId&quot;: 1793, &quot;sysPostId&quot;: 10000000000003, &quot;orgId&quot;: 10031, &quot;orgName&quot;: &quot;太原市分公司&quot;, &quot;regionId&quot;: 8140100, &quot;regionName&quot;: &quot;太原市&quot;, &quot;staffId&quot;: 10000000000005, &quot;staffName&quot;: &quot;测试修改改&quot;, &quot;systemInfoId&quot;: 1000, &quot;lanId&quot;: 8140100, &quot;lanName&quot;: &quot;太原市&quot;&#125; 刷新 acess_token POST http://172.21.2.41:9010/oauth/token Request Headers: 12345678POST /oauth/tokenContent-Type: application/x-www-form-urlencodedcache-control: no-cacheAuthorization: Basic YnNzLWxvZ2luOmJzcy1sb2dpbi0yMDE4Accept: */*Host: 172.21.2.41:9010accept-encoding: gzip, deflatecontent-length: 75 Request Body: 1grant_type=refresh_token&amp;refresh_token=5a4d7d4e-de41-4f97-9785-52e42a10c6c9 Response Headers: 12345678910HTTP/1.1 200status: 200Pragma: no-cacheCache-Control: no-storeX-Content-Type-Options: nosniffX-XSS-Protection: 1; mode=blockX-Frame-Options: DENYContent-Type: application/json;charset=UTF-8Transfer-Encoding: chunkedDate: Wed, 09 Jan 2019 08:31:39 GMT Response Body:1234567&#123; &quot;access_token&quot;: &quot;4114f01b-a43a-44cc-903b-1b31550b25bf&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;refresh_token&quot;: &quot;5a4d7d4e-de41-4f97-9785-52e42a10c6c9&quot;, &quot;expires_in&quot;: 43199, &quot;scope&quot;: &quot;user&quot;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}